/***************************************************************************
 *   Copyright (C) 2011 by Marco Beccuti   *
 *   beccuti@di.unito.it   *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#ifndef __CIO_H__
	#define __CIO_H__
	#include "classIO.h"
#endif
#include<unistd.h>

namespace IOFn {

template <class A_Type>
void IOF<A_Type>::Read(){

using namespace general;

clock_t startGlobal,endGlobal;

unsigned int num;
char buffer[MAXSIZE];

ifstream in;
//FILE* in;

char delimC[] = ".";
Parser parser;
parser.update(delimC,ReadFname);

//DEBUG
cout << "[classIO:Read]Before processing all pools sh has size " << sh.size() << " and capacity " << sh.capacity() << endl; 

for (unsigned int i=0;i<numFiles;i++)
{
ostringstream of;
of<<parser.get(0)<<i<<"."<<parser.get(1);//<<"."<<parser.get(2)<<"."<<parser.get(3);
//DEBUG
cout << endl << "***Pool " << of.str() << "***" << endl;

in.open(of.str().c_str(),ifstream::in);
if(!in) 
	{
	cerr << "\nError opening input file " << of.str() << endl;
	exit(EXIT_FAILURE);
	}

startGlobal=clock();
while (in.good())
	{
	buffer[0]='\0';
	//if (fgets(buffer, MAXSIZE, in)==NULL)
	//	break;
	in.getline(buffer,MAXSIZE);
	//num=in.gcount();
	num=strlen(buffer);
	/*if (buffer[num-1]=='\n') {
		buffer[num-1]='\0';
		num--;
	}*/
	if ((num>=kmerSize+1)&&((buffer[0]=='A')||(buffer[0]=='G')||(buffer[0]=='C')||(buffer[0]=='T')||(buffer[0]=='N')))
		{
			insert(buffer,num,i);
			/*if(numReads%20000000==0) {
				cout<<"[Read]reads so far: "<<numReads<<" : "<<" stored kmers: "<<sh.size()<<" rejected  kmers: "<<numDiscard<<endl;
				//sh.print();
				sh.info();
			}	*/
		}
	}//end while (!in.eof())

in.close();
//fclose(in);
endGlobal=clock();
cout << "\n[classIO:Read]Time to read pool "<<i<<": "<<((double)(endGlobal-startGlobal))/CLOCKS_PER_SEC<<"s."<<endl;
//cout<<"Reads: "<<readCounts[i]<<" kmers: "<<kmerCounts[i]<<" kmers stored so far: "<<sh.size()<<endl;
};

//DEBUG
cout << "\n[classIO:Read]After reading all pools sh has size " << sh.size() << " and capacity " << sh.capacity() << endl << endl; 

};

template <class A_Type>
void IOF<A_Type>::ReadLight() {

using namespace general;

clock_t startGlobal,endGlobal;

/*Inits*/

HashTable<mybitset> shLight;
HashTable<mybitset> me[F];
HashTable<mybitset> others[F];
shLight.allocHash();
for (int f=0; f<F; f++) {
	me[f].allocHash();
	others[f].allocHash();
};

unsigned int num;
char buffer[MAXSIZE];

ifstream in;
//FILE* in;

char delimC[] = ".";
Parser parser;
parser.update(delimC,ReadFname);
/*string fileExt="";
if (parser.size()>1)
	{
	fileExt=parser.get(1);
	}
*/
//DEBUG
cout << endl;
cout << "[ReadLight]shLight size is " << shLight.size() << " and capacity " << shLight.capacity() << endl; 
for (int f =0; f<F; f++) {
	cout << "[ReadLight]me[" <<  f << "] size is " << me[f].size() << " and capacity " << me[f].capacity() << endl;
	cout << "[ReadLight]others[" <<  f << "] size is " << others[f].size() << " and capacity " << others[f].capacity() << endl;
	}
cout << endl;	


for (unsigned int i=0;i<numFiles;i++)
{
ostringstream of;
of<<parser.get(0)<<i<<"."<<parser.get(1);//<<"."<<parser.get(2)<<"."<<parser.get(3);

in.open(of.str().c_str(),ifstream::in);
//DEBUG
cout << endl << "***Pool " << of.str() << "***" << endl;
if(!in) 
	{
	cerr << "\nError opening input file " << of.str() << endl;
	exit(EXIT_FAILURE);
	}

startGlobal=clock();
while (in.good()) {
	buffer[0]='\0';
	//if (fgets(buffer, MAXSIZE, in)==NULL) 
	//	break;
	in.getline(buffer,MAXSIZE);
	//num=in.gcount();
	num=strlen(buffer);
	/*if (buffer[num-1]=='\n') {
		buffer[num-1]='\0';
		num--;
	}*/
	if ((num>=kmerSize+1)&&((buffer[0]=='A')||(buffer[0]=='G')||(buffer[0]=='C')||(buffer[0]=='T')||(buffer[0]=='N')))
		{
			readCounts[i]++;
			insertLight(shLight, me, others, buffer, num, i);
			
			/*if(readCounts[i]%500000==0) {
				cout<<"[ReadLight]Reads so far: "<<readCounts[i]<<", stored kmers: "<<shLight.size()<<", numDiscard "<<numDiscard<<endl;
			}*/	
		}
	};//end while(!in.eof())

numReads+=readCounts[i];

in.close();
//fclose(in);
endGlobal=clock();
cout << "\nTime to read pool "<<i<<": "<<((double)(endGlobal-startGlobal))/CLOCKS_PER_SEC<<"s."<<endl;
cout<<"Reads in this pool: "<<readCounts[i]<<" kmers: "<<kmerCounts[i]<<" kmers stored so far: "<<shLight.size() << " k-mers discarded " << numDiscard <<endl;

//DEBUG
cout << "\n[ReadLight]After processing pool " << i << endl;
cout << "shLight has size " << shLight.size() << ", capacity " << shLight.capacity() << " and ratio " << shLight.size()/((double)shLight.capacity()) << endl; 
for (int f = 0; f < F; f++) {
	cout << "me[" << f << "] has size " << me[f].size() << ", capacity " << me[f].capacity() << " and ratio " << me[f].size()/((double)me[f].capacity()) << endl; 
	cout << "others[" << f << "] has size " << others[f].size() << ", capacity " << others[f].capacity() << " and ratio " << others[f].size()/((double)others[f].capacity()) << endl; 
};
cout << endl;


//after processing all reads for pool i copy all me hashtables into the others hashtable 
//before continuing with the next pool
//if (i < (numFiles-1)) {
	for (int f = 0; f < F; f++) {
		//DEBUG
		cout << "[ReadLight]Moving me[" << f << "] into others[" << f << "]..." << endl;  
		others[f].insert(me[f]);
		cout << "[ReadLight]Done moving." << endl;
		me[f].makeEmpty();
	};
//};

//DEBUG
cout << "\n[ReadLight]After processing pool " << i << " and moving me to others " << endl;
cout << "shLight has size " << shLight.size() << ", capacity " << shLight.capacity() << " and ratio " << shLight.size()/((double)shLight.capacity()) << endl; 
for (int f = 0; f < F; f++) {
	cout << "me[" << f << "] has size " << me[f].size() << ", capacity " << me[f].capacity() << " and ratio " << me[f].size()/((double)me[f].capacity()) << endl; 
	cout << "others[" << f << "] has size " << others[f].size() << ", capacity " << others[f].capacity() << " and ratio " << others[f].size()/((double)others[f].capacity()) << endl; 
};
cout << endl;


}//end for each pool

/*cout << "[ReadLigh]Before calling makeEmpty() shLight has " << shLight.countElements() << " elemnts" << endl;
for (int f=0; f<F;f++) {
	cout << "[ReadLigh]Before calling makeEmpty() me[" << f << "] has " << me[f].countElements() << " elemnts" << endl;
	cout << "[ReadLigh]Before calling makeEmpty() others[" << f << "] has " << others[f].countElements() << " elemnts" << endl;
}*/

//delete all me and others hash tables
/*for (int f=0; f<F;f++) {
	me[f].makeEmpty();
	others[f].makeEmpty();
}*/

/*delete [] me;
delete [] others;*/

/*cout << "[ReadLigh]After calling makeEmpty() shLight has " << shLight.countElements() << " elemnts" << endl;
for (int f=0; f<F;f++) {
	cout << "[ReadLigh]After calling makeEmpty() me[" << f << "] has " << me[f].countElements() << " elements" << endl;
	cout << "[ReadLigh]After calling makeEmpty() others[" << f << "] has " << me[f].countElements() << " elemnts" << endl;
}*/


//resize down the hashtable if necessary
//FIXME
/*if (shLight.size()/((double)shLight.capacity()) <= MIN) {  
	cout <<"[ReadLight]shLight has size " << shLight.size() << ", capacity " << shLight.capacity() << " ratio " << shLight.size()/((double)shLight.capacity()) << " resizing down!!! " << endl;
	shLight.resize(0);
}*/

//copy shLight to sh
//cout << "[ReadLight]Inserting all the elements from shLight into sh..." << endl;
//insertAll(shLight, sh);
//cout << "[ReadLight]After insertion shLight has size " << shLight.size() << " and capacity " << shLight.capacity() << endl; 
//cout << "[ReadLight]After insertion sh has size " << sh.size() << " and capacity " << sh.capacity() << endl; 

//write shLight to disk instead to save space
shLight.Write(parser.get(0));

cout <<"\n[ReadLight]Done reading " << numFiles << " pools for a total of " << numReads << " reads." << endl;
};

template <class A_Type>
void IOF<A_Type>::ReadIntermediate() {
	using namespace general;
	
	char delimC[] = ".";
	Parser parser;
	parser.update(delimC,ReadFname);
	
	HashTable<mybitset> shLight;
	shLight.Read(parser.get(0));
	cout << "\n[ReadIntermediate]After reading from file shLight has size " << shLight.size() << " and capacity " << shLight.capacity() << endl; 
	
	cout << "[ReadIntermediate]Inserting all the elements from shLight into sh..." << endl;
	insertAll(shLight, sh);
	cout << "[ReadIntermediate]After insertion shLight has size " << shLight.size() << " and capacity " << shLight.capacity() << endl; 
	cout << "[ReadIntermediate]After insertion sh has size " << sh.size() << " and capacity " << sh.capacity() << endl; 

};

template <class A_Type>
void IOF<A_Type>::compareTables() {
	using namespace general;
	//cmpTables(shOld, sh);
};

template <class A_Type>
void IOF<A_Type>::Write(){
ofstream pFile;

time_t time_1,time_4;


time(&time_1);


pFile.open(OFname.c_str(),ofstream::out);
if (!pFile)
	{
	cerr << "\n*****Error opening ouput file *****" << endl;
	exit(EXIT_FAILURE);
	}

//set<class mybitset>::iterator iter=sh.begin();
pFile<<"W:"<<kmerSize<<" |W|:"<<sh.size()<<" R:"<<numReads<<endl;
pFile.close();
time(&time_4);
cout<<"Time to format input REFERENCE: "<<(time_4-time_1)<<endl;
};


				
template <class A_Type>
void IOF<A_Type>::insert(const char buffer[],unsigned  int num,unsigned int pool){
A_Type b,d;
for(unsigned int k=0; k<=num-(kmerSize)-1; k++)
	{
	int z=0;
	int j=DIM*2-1;
	bool findN=false;
	for (unsigned int c = 0; c<kmerSize; c++) 
		{
              	switch (buffer[c+k])
			{
			case 'A':
				b.set(z,0);
				z++;
				b.set(z,0);
				z++;
				d.set(j,1);
				j--;
				d.set(j,1);
				j--;
			break;
			case 'C':
				b.set(z,0);
				z++;
				b.set(z,1);
				z++;
				d.set(j,0);
				j--;
				d.set(j,1);
				j--;
			break;
			case 'G':
				b.set(z,1);
				z++;
				b.set(z,0);
				z++;
				d.set(j,1);
				j--;
				d.set(j,0);
				j--;
			break;
			case 'T':
				b.set(z,1);
				z++;
				b.set(z,1);
				z++;
				d.set(j,0);
				j--;
				d.set(j,0);
				j--;
			break;
			default:
				findN=true;
				c=kmerSize;
			}
		}
	if (!findN) {
		kmerCounts[pool]++;
		if (d<b) 
			sh.searchIncPool(d,pool);
		 else 
			sh.searchIncPool(b,pool);
	} else
		numDiscard++;
	}
};


template <class A_Type>
void IOF<A_Type>::insertLight(HashTable<mybitset>& shLight, 
	HashTable<mybitset> me[F], HashTable<mybitset> others[F], const char buffer[], int num, int pool)
{
	
bool found;
int f;
class mybitset b,d,e;
for(unsigned int k=0; k<=num-(kmerSize)-1; k++)
	{
	int z=0;
	int j=DIM*2-1;
	bool findN=false;
	for (unsigned int c = 0; c<kmerSize; c++) 
		{
              	switch (buffer[c+k])
			{
			case 'A':
				b.set(z,0);
				z++;
				b.set(z,0);
				z++;
				d.set(j,1);
				j--;
				d.set(j,1);
				j--;
			break;
			case 'C':
				b.set(z,0);
				z++;
				b.set(z,1);
				z++;
				d.set(j,0);
				j--;
				d.set(j,1);
				j--;
			break;
			case 'G':
				b.set(z,1);
				z++;
				b.set(z,0);
				z++;
				d.set(j,1);
				j--;
				d.set(j,0);
				j--;
			break;
			case 'T':
				b.set(z,1);
				z++;
				b.set(z,1);
				z++;
				d.set(j,0);
				j--;
				d.set(j,0);
				j--;
			break;
			default:
				findN=true;
				c=kmerSize;
			}
		}
	if (!findN)
	{
		kmerCounts[pool]++;
		f = F - 1;
		found = false;
		if (d<b) 
			e=d;
		else
			e=b;
		
		/*insert e into the hashtable*/
		
		//if (pool >0)
		//	cout << "[InsertLight]inserting " << e << " into the hashtable " << endl;

		if (shLight.search(e)) { 
				//if (pool >0)
				//	cout << "[insertLight]kmer found in sh" << endl;
				
				//if the k-mer is found in keep do nothing 
			found = true; 
		} 
		while ((found==false) && (f >= 0)) {
				
			if (others[f].search(e)) {
				
				//if (pool >0)
				//	cout << "[insertLight]kmer found in others[" << f << "]" << endl;
				
				found = true;
				others[f].removeCopy(e);
				
				if (f == (F - 1)) {//move the k-mer to keep 
						
					//if (pool>0)
					//	cout<< "[insertLight] pool " << pool<< " " << f << "==" << (F-1) << endl;
					
					shLight.insert(e);
				} 
				else { //move the k-mer from others[f] to me[f+1]
						
					//if (pool >0)
					//	cout << "[insertLight]pool  " << pool << f << "!=" << (F-1) << endl;
					
					me[f+1].insert(e);
				}
			} else if (me[f].search(e)) { 
				
				//if (pool >0)
				//	cout << "[insertLight]kmer found in me[" << f << "]" << endl;
				
				//if the k-mer is found in me do nothing 
				found = true; 
			};
			
			f--;

		} //end while ((!found) && (f >= 0))
			
		if (found == false) {
				
			//if (pool >0)
			//	cout << "[insertLight]kmer " << e << " about to be inserted in me[0]" << endl;
			
			me[0].insert(e);
		}; 	
	} //if (!findN)
	else
		numDiscard++;
	}
};


template <class A_Type>
inline void IOF<A_Type>::convertN(char tmp[], const int& num)
{
char inv[MAXSIZE];
string kk;
for (int i=0;i<num;i++)
		{
		switch (tmp[i])
			{
			case 'A':
				inv[num-i-2]='T';
				kk+='T';
			break;
			case 'C':
				inv[num-i-2]='G';
				kk+='G';
			break;
			case 'G':
				inv[num-i-2]='C';
				kk+='C';
			break;
			case 'T':  
				inv[num-i-2]='A';
				kk+='A';
			break;
			case '\0':
 				inv[num-1]='\0';
			break;
			default:
				inv[num-i-2]='N';	
			}
		}
strcpy(tmp,inv);
};


/*void IOF::Average(vector<class OPERATOR>::iterator it,int i){

ostringstream of;
of<<OFname<<i;
ofstream out(of.str().c_str(),ofstream::out);
if (!out)
	{
	cerr << "\n*****Error opening ouput file *****" << endl;
	exit(EXIT_FAILURE);
	}

sh.Average(out,it,count);

// #if REPET
// //sh.CountR(out,count);
// sh.Corretion(out,count);
// #endif
cout<<"\t Output  operation "<<i<<" save in "<<of.str().c_str()<<endl;
out.close();
}*/

/*void IOF::Count(int i){
ostringstream of;
of<<OFname<<i;
ofstream out(of.str().c_str(),ofstream::out);
if (!out)
	{
	cerr << "\n*****Error opening ouput file *****" << endl;
	exit(EXIT_FAILURE);
	}

sh.Count(out);
cout<<"\t Output  operation "<<i<<" save in "<<of.str().c_str()<<endl;
out.close();
}*/


/*void IOF::Search(int l,int u){

using namespace general;

HashTable<mybitset> rd;
rd.updateHash(READSIZE-kmerSize);

char buffer[MAXSIZE],name[MAXSIZE],name2[MAXSIZE];

ifstream in;
ofstream out;

int num=0;
clock_t startGlobal,endGlobal;
mybitsetBAC p;

char delimC[] = ".";
Parser parser;
parser.update(delimC,ReadFname);
string fileExt="";
if (parser.size()>1)
	{
	fileExt=parser.get(1);
	}
for (int i=l;i<=u;i++)
{
startGlobal=clock();
ostringstream of,of1;

#if FASTAEXFILE
of<<parser.get(0)<<i<<"."<<fileExt;
#else
of<<parser.get(0)<<i<<"."<<fileExt;
#endif
//#pragma omp parallel
//{
//int i = omp_get_thread_num();
cout << "[Search] " << fileExt << " in file " << of.str() << endl;
//}

in.open(of.str().c_str(),ofstream::in);
if(!in) 
	{
	cerr << "\n*****Error opening input file *****" << endl;
	exit(EXIT_FAILURE);
	}
of1<<OFname<<i;
out.open(of1.str().c_str(),ofstream::out);
if (!out)
	{
	cerr << "\n*****Error opening ouput file *****" << endl;
	exit(EXIT_FAILURE);
	}

int dec=0;
int pdec=0;
while (!in.eof())
	{
	buffer[0]='\0';
	in.getline(buffer,MAXSIZE);
	num=in.gcount();
	if (buffer[num-1]!='\0')
		{
		buffer[num]='\0';
		num++;
		}
	if ((num>=kmerSize+1)&&((buffer[0]=='A')||(buffer[0]=='G')||(buffer[0]=='C')||(buffer[0]=='T')||(buffer[0]=='N'))) {
			p=search(rd,buffer,num,out);
	#if OUTPUTPOOLSDEC
			out<<name<<"\n";
			out<<buffer<<"\n";
	#else
		#if  OUTPUTPOOLS
			out<<name<<":$";
		#endif
	#endif
	} else
		if ((num>0)&&((buffer[0]=='@')||(buffer[0]=='>'))) {
			strcpy(name,buffer);
			p.clear();
		}	
	}

in.close();
out.close();
endGlobal=clock();
}//end for
};*/


/*mybitsetBAC  IOF::search(class HashTable<mybitset>& rd,const char buffer[],const int& num,ofstream& out )
{
mybitsetBAC p;
class mybitset b,d;
for(int k=0; k<=num-(kmerSize)-1; k++)
	{
	int z=0;
	int j=DIM*2-1;
	bool findN=false;
	for (int c = 0; c<kmerSize; c++) 
		{
              	switch (buffer[c+k])
			{
			case 'A':
				b.set(z,0);
				z++;
				b.set(z,0);
				z++;
				d.set(j,1);
				j--;
				d.set(j,1);
				j--;
			break;
			case 'C':
				b.set(z,0);
				z++;
				b.set(z,1);
				z++;
				d.set(j,0);
				j--;
				d.set(j,1);
				j--;
			break;
			case 'G':
				b.set(z,1);
				z++;
				b.set(z,0);
				z++;
				d.set(j,1);
				j--;
				d.set(j,0);
				j--;
			break;
			case 'T':
				b.set(z,1);
				z++;
				b.set(z,1);
				z++;
				d.set(j,0);
				j--;
				d.set(j,0);
				j--;
			break;
			default:
				findN=true;
				c=kmerSize;
			}
		}
	if (!findN)
		{
		z=0;	
		if (d<b)
			{
			rd.insert(d);
			}
		else
			{
			rd.insert(b);
			}
		}
	}
	if (rd.size()!=0)
 		p=rd.search(sh,shBAC);
#if OUTPUT
	out<<p<<endl;
#endif
return p;
}*/


template <class A_Type>
void IOF<A_Type>::ReadBac(){

using namespace general;

char delimC[] = "\t,";
int  PoolsBac[BACS][8];
Parser parser;
ifstream in;

in.open(BACFname.c_str(),ofstream::in);
if(!in) 
	{
	cerr << "\nError opening " << BACFname  << endl;
	exit(EXIT_FAILURE);
	}
char buffer[MAXSIZE];
int j=0;
while (!in.eof()) {
	buffer[0]='\0';
	in.getline(buffer,MAXSIZE);
	if (buffer[0]!='\0') {
		int num=in.gcount();
		if (buffer[num-1]!='\0') {
			buffer[num]='\0';
		}
		parser.update(delimC,buffer);	
		for (unsigned int i=0; i< parser.size(); i++ ) {
               		PoolsBac[j][i]=(atoi (parser.get(i).c_str()))-1;
		}
		j++;
	}
}	
in.close();
for (unsigned int j=0; j<BACS; j++ ) {
	mybitsetBAC p;
	p.set(PoolsBac[j][0]);//set BAC ID 
	for (unsigned int i=1; i<8; i++ ) {
               	p.setPool(PoolsBac[j][i]);
		//cout << PoolsBac[j][i] << " "; 
	}
	//cout << endl;
	if (shBAC.search(p)==0)
		shBAC.insert(p);
}

cout << "shBAC size " << shBAC.size() << endl;
};


};
